<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>

  <link rel="stylesheet" href="css/style.css">

  <style type="text/css">

  </style>
</head>
<body>


<div class="cover" id="cover">
  <h1>Please Click To Get In</h1>
  <h2>Auther:Mario  Email:739880760@qq.com</h2>
  <div class="ghost">
    <div class="body">
      <div class="face">
        <div class="eye left"></div>
        <div class="eye right"></div>
        <div class="smile"></div>
        <div class="rosy left"></div>
        <div class="rosy right"></div>
      </div>
      <div class="arm left"></div>
      <div class="arm right"></div>
      <div class="bottom">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
      </div>
    </div>
    <div class="shadow"></div>
  </div>
</div>
<div class="realPage">
  <div class="headWrap">

  </div>
  <div class="mainWrap">


    # pakeage.lock.json官方文档解释 #<br>
    ## 描述 ##<br>
    package-lock.json会自动为npm修改node_modules树或任何操作而生成package.json。它描述了生成的确切树，以便后续安装能够生成相同的树，而不管中间依赖性更新如何。<br>

    这个文件旨在被提交到源代码库，并提供各种##用途：##<br>

    描述依赖关系树的单一表示，以确保队友，部署和持续集成确保安装完全相同的依赖关系。<br>

    为用户提供一个设施，使其能够“前往”以前的状态，node_modules而不必提交目录本身。<br>

    通过可读的源代码控制差异来促进树更改的更大可见性。<br>

    并通过允许npm跳过先前安装的软件包的重复元数据分辨率来优化安装过程。<br>

    一个关键的细节package-lock.json是它不能被发布，并且如果在顶层包之外的任何地方发现它将被忽略。它与npm-shrinkwrap.json共享格式，它基本上是相同的文件，但允许发布。除非部署CLI工具或以其他方式使用发布过程来生产产品包，否则不建议这样做。<br>

    如果两个package-lock.json和npm-shrinkwrap.json存在于包的根，package-lock.json将被完全忽略。<br>

    #文件格式#<br>
    ##名称##<br>
    包的名称，这是一个包锁。这必须与内容匹配 package.json。<br>

    ##版##<br>
    包的版本，这是一个包锁。这必须与内容匹配 package.json。<br>

    lockfileVersion<br>
    整数版本，1从此文档的版本号开始，在生成此版本时使用其语义package-lock.json。<br>

    packageIntegrity<br>
    这是从该创建的子资源完整性值package.json。不package.json应该进行预处理。子资源完整性字符串可以由模块生成 ssri。<br>

    preserveSymlinks<br>
    表示安装是在NODE_PRESERVE_SYMLINKS启用环境变量的情况下完成的 。安装程序应该坚持该属性的值与该环境变量相匹配。<br>

    ##依赖##<br>
    包名称到依赖对象的映射。依赖项对象具有以下属性：<br>

    ##版##<br>
    这是一个说明符，它唯一标识了这个包，并且可以用来获取它的新副本。<br>

    捆绑的依赖关系：无论来源如何，这是纯粹用于信息目的的版本号。<br>
    注册表来源：这是一个版本号。（例如1.2.3）<br>
    git sources：这是一个解析commitit的git说明符。（例如git+https://example.com/foo/bar#115311855adb0789a0466714ed48a1499ffea97e）<br>
    http tarball来源：这是tarball的URL。（例如https://example.com/example-1.3.0.tgz）<br>
    本地tarball源码：这是tarball的文件URL。（例如file:///opt/storage/example-1.3.0.tgz）<br>
    本地链接源：这是链接的文件URL。（例如file:libs/our-module）<br>
    ##廉正##<br>
    这是此资源的标准子资源完整性。<br>

    对于捆绑的依赖项，不包括源代码。<br>
    对于注册表来源，这是integrity注册表提供的，或者没有提供SHA1的shasum。<br>
    对于git来源，这是我们克隆的特定提交散列。<br>
    对于远程tarball源，这是基于文件SHA512的完整性。<br>
    对于本地压缩包来源：这是一个基于文件SHA512的完整性字段。<br>
    ##解决##<br>
    对于捆绑的依赖项，不包括源代码。<br>
    对于注册表来源，这是相对于注册表URL的tarball路径。如果tarball URL与注册表URL不在同一台服务器上，那么这是一个完整的URL。<br>
    ##捆绑##<br>
    如果为true，则这是捆绑的依赖关系，并将由父模块进行安装。安装时，此模块将在提取阶段从父模块中提取，而不是作为单独的依赖项安装。<br>

    ##开发##<br>
    如果为true，那么这个依赖是或者是顶层模块的开发依赖，或者是一个依赖的传递依赖。这对于既是顶级开发依赖性又是顶级非开发依赖性的传递依赖性的依赖性是错误的。<br>

    ##可选的##<br>
    如果为true，那么这个依赖是或者是顶层模块的可选依赖，或者是一个可传递的依赖。对于既是顶层可选依赖项又有顶层非可选依赖项的传递依赖项的依赖项，这是错误的。<br>

    即使在当前平台上可以卸载，也应包含所有可选的依赖关系。<br>

    ##依赖##<br>
    这个依赖关系的依赖关系，就像在顶层一样。<br>
  </div>
  <div class="footerWrap">

  </div>
</div>
</body>
<script>
  let cover = document.querySelector(".cover")
  let real = document.querySelector(".realPage")
  cover.onclick = function () {
    console.log(1)
//    this.style.opacity = 0
    this.style.display = "none"
    real.style.display = "block"
  }

</script>
</html>